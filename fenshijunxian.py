# coding:UTF-8from pandas import DataFramefrom time import sleep, localtime, clock, time, strptime, strftimefrom datetime import datetimefrom csv import readerfrom functions import calculate_sleep_loop, get_seconds, get_today_1min_table_namefrom constant import PATH_ALL_CODE, URL, PAGE_NUMBERS, REDUNDANT_NUMBERS_CHARS_IN_LINE, INTERVAL_SECONDS, ENGINE,\    MIN_RATIO_BETWEEN_CLOSE_AND_AVPimport sockettry:    from urllib.request import urlopen, Requestexcept ImportError:    from urllib2 import urlopen, Requestdef parse_data_string(para_string):    return_list = []    if len(para_string) < 40:        return return_list    str1 = para_string[para_string.find('"')+1:len(para_string)-REDUNDANT_NUMBERS_CHARS_IN_LINE]    str_list = str1.split(',')    # stock_name = str_list[0]    open_price = float(str_list[1])    settlement = float(str_list[2])    latest_price = float(str_list[3])    high_price = float(str_list[4])    low_price = float(str_list[5])    buy1_price = float(str_list[6])    sell1_price = float(str_list[7])    volume = int(str_list[8])    amount = long(str_list[9][0:str_list[9].find('.')])    trading_date = str_list[30]    trading_time = str_list[31]    quote_datetime = datetime.strptime(trading_date + ' ' + trading_time, "%Y-%m-%d %H:%M:%S")    return_list = [open_price, settlement, latest_price, high_price, low_price, buy1_price,                   sell1_price, volume, amount, quote_datetime]    return return_listdef get_data_from_web(code_str):    global total_loop_counter    # code_str is a long string containing many stock codes split by comma    code_list = code_str.split(',')    url = URL+'%s' % code_str    try:        request = Request(url)        lines = urlopen(request, timeout=20).read()        data_list = lines.split(';')        del data_list[len(data_list)-1]        result_list = []        for i in range(0, len(data_list)):            single_stock_list = parse_data_string(data_list[i])            if len(single_stock_list) == 0:                continue            else:                if single_stock_list[8] != 0:                    single_stock_list.insert(0, code_list[i])                    result_list.append(single_stock_list)        return result_list    except socket.timeout:        print 'a timeout error happens , continue catch data '        data_to_sql()    except:        print 'another kind of exception happens, continue catch data'        data_to_sql()def get_quotedata_list():    with open(PATH_ALL_CODE, 'r') as csv_file:        spam_reader = reader(csv_file, delimiter=' ', quotechar='|')        controller = 0        counter = 0        final_list = []        code_str = ''        for row in spam_reader:            controller += 1            counter += 1            if controller % PAGE_NUMBERS == 1:                code_str = row[0]            else:                code_str = code_str+','+row[0]            if controller == PAGE_NUMBERS:                final_list.extend(get_data_from_web(code_str))                controller = 0                code_str = ''        if controller != 0 and controller < PAGE_NUMBERS:            final_list.extend(get_data_from_web(code_str))    csv_file.close()    return final_listdef data_to_sql():    global time_recorder    start = clock()    li = get_quotedata_list()    stock_list = []    for i in range(0, len(li)):        stock_list.append(li[i][0])        del li[i][0]    df1 = DataFrame(li, columns=['open', 'settlement', 'close', 'high', 'low', 'buy1_price',                                 'sell1_price', 'volume', 'amount', 'datetime'], index=stock_list)    df1.index.name = 'stockcode'    temp_df = df1.pop('datetime')    df1.insert(0, 'datetime', temp_df)    df1.insert(8, 'av_p', df1['amount']/df1['volume'])    indicator = DataFrame(df1['close'] / df1['av_p'], index=df1.index, columns=list(['indicator']))    indicator[indicator >= MIN_RATIO_BETWEEN_CLOSE_AND_AVP] = 1    indicator[indicator <= MIN_RATIO_BETWEEN_CLOSE_AND_AVP] = 0    df1['indicator'] = indicator    df1['p_change'] = (df1['close']/df1['settlement'] - 1) * 100    series_index = DataFrame([total_loop_counter]*len(li), index=df1.index, columns=list(['series_index']))    df1.insert(1, 'series_index', series_index)    ENGINE.execute('create table if not exists %s like table_template' % table_name)    df1.to_sql(table_name, ENGINE, if_exists='append')    end = clock()    time_recorder = end-startdef main():    global total_loop_counter    global table_name    t = localtime(time())    table_name = get_today_1min_table_name()    delay_loop = calculate_sleep_loop(t)    if len(delay_loop) > 0:        sleep(delay_loop[0])        total_loop_counter = 240 - delay_loop[1]        for i in range(0, delay_loop[1]):            total_loop_counter += 1            data_to_sql()            sleep_time = INTERVAL_SECONDS - time_recorder            print 'the current loop is %d ' % total_loop_counter            if total_loop_counter == 120:                now_time = localtime(time())                today = strftime("%Y%m%d")                kaipan_pm = strptime('%s 13:01:00' % today, '%Y%m%d %H:%M:%S')                sleep(get_seconds(kaipan_pm, now_time))            else:                sleep(sleep_time)    else:        print "the trading is over!"        sleep(5)        download_dailydata()        print 'already download dailydata'time_recorder = 0total_loop_counter = 0table_name = ''main()