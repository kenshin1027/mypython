# coding:UTF-8from pandas import DataFramefrom time import sleep, localtime, clock, time, strptimefrom datetime import datetimefrom csv import readerfrom sqlalchemy import create_enginePAGE_NUMBERS = 100REDUNDANT_NUMBERS_CHARS_IN_LINE = 4INTERVAL_SECONDS = 60URL = 'http://hq.sinajs.cn/list='PATH_ALL_CODE = r'C:\Users\zzw\Desktop\allcode.csv'try:    from urllib.request import urlopen, Requestexcept ImportError:    from urllib2 import urlopen, Requestdef calculate_sleep_loop(para_time):    if para_time.tm_sec <= 2:        delay_sec = 0        t_hour = para_time.tm_hour        t_min = para_time.tm_min    else:        delay_sec = 60-para_time.tm_sec        if para_time.tm_min == 59:            t_min = 0            t_hour = para_time.tm_hour+1        else:            t_hour = para_time.tm_hour            t_min = para_time.tm_min+1    print "t.tm_hour is:%d" % para_time.tm_hour    if para_time.tm_hour < 12:        print "t_hour is:%d, t_min is:%d" % (t_hour, t_min),        loop_times = 240-(t_hour*60+t_min-9*60-31)    else:        loop_times = 15*60-t_hour*60-t_min+1    return [delay_sec, loop_times]def parse_data_string(para_string):    return_list = []    if len(para_string) < 40:        return return_list    str1 = para_string[para_string.find('"')+1:len(para_string)-REDUNDANT_NUMBERS_CHARS_IN_LINE]    str_list = str1.split(',')    # stock_name = str_list[0]    open_price = float(str_list[1])    settlement = float(str_list[2])    latest_price = float(str_list[3])    high_price = float(str_list[4])    low_price = float(str_list[5])    buy1_price = float(str_list[6])    sell1_price = float(str_list[7])    volume = int(str_list[8])    amount = long(str_list[9][0:str_list[9].find('.')])    trading_date = str_list[30]    trading_time = str_list[31]    quote_datetime = datetime.strptime(trading_date + ' ' + trading_time, "%Y-%m-%d %H:%M:%S")    return_list = [open_price, settlement, latest_price, high_price, low_price, buy1_price,                   sell1_price, volume, amount, quote_datetime]    return return_listdef get_data_from_web(code_str):    # code_str is a long string containing many stock codes split by comma    code_list = code_str.split(',')    url = URL+'%s' % code_str    # print 'code_str is:%s' % code_str    # print 'url is:%s' % url    request = Request(url)    lines = urlopen(request, timeout=10).read()    data_list = lines.split(';')    del data_list[len(data_list)-1]    # single_stock_list = []    result_list = []    for i in range(0, len(data_list)):        single_stock_list = parse_data_string(data_list[i])        if len(single_stock_list) == 0:            continue        else:            if single_stock_list[8] != 0:                single_stock_list.insert(0, code_list[i])                result_list.append(single_stock_list)    return result_listdef get_quotedata_list():    with open(PATH_ALL_CODE, 'r') as csv_file:        spam_reader = reader(csv_file, delimiter=' ', quotechar='|')        controller = 0        counter = 0        final_list = []        code_str = ''        for row in spam_reader:            controller += 1            counter += 1            if controller % PAGE_NUMBERS == 1:                code_str = row[0]            else:                code_str = code_str+','+row[0]            if controller == PAGE_NUMBERS:                final_list.extend(get_data_from_web(code_str))                controller = 0                code_str = ''        if controller != 0 and controller < PAGE_NUMBERS:            final_list.extend(get_data_from_web(code_str))    print 'actually return %d records' % len(final_list)    print 'should   return %d records!' % counter    csv_file.close()    return final_listdef data_to_sql():    global time_recorder    global stock_list    start = clock()    li = get_quotedata_list()    end = clock()    stock_list=[]    print "get data costs: %.4f second" % (end - start)    for i in range(0, len(li)):        stock_list.append(li[i][0])        del li[i][0]    df1 = DataFrame(li, columns=['open', 'settlement', 'close', 'high', 'low', 'buy1_price',                                 'sell1_price', 'volume', 'amount', 'datetime'], index=stock_list)    df1.index.name = 'stockcode'    temp_df = df1.pop('datetime')    df1.insert(0, 'datetime', temp_df)    df1.insert(8, 'av_p', df1['amount']/df1['volume'])    indicator = DataFrame(df1['close'] / df1['av_p'], index=df1.index, columns=list(['indicator']))    indicator[indicator >= 0.994] = 1    indicator[indicator <= 0.994] = 0    df1['indicator'] = indicator    series_index = DataFrame([total_loop_counter]*len(li), index=df1.index, columns=list(['series_index']))    df1.insert(1, 'series_index', series_index)    engine = create_engine('mysql://root:@localhost/stockdata?charset=utf8')    engine.execute('create table if not exists %s like table_template' % table_name)    df1.to_sql(table_name, engine, if_exists='append')    end = clock()    time_recorder = end-startdef start_run(loop_num):    global total_loop_counter    for i in range(0, loop_num):        total_loop_counter += 1        start = clock()        data_to_sql()        print 'time_recorder is:%f' % time_recorder        end = clock()        print "run %d loop and costs: %.4f second" % (total_loop_counter, end - start)        sleep(INTERVAL_SECONDS - time_recorder)time_recorder = 0total_loop_counter = 0stock_list = []# table_name = ''t = localtime(time())today = str(t.tm_year)+str(t.tm_mon)+str(t.tm_mday)table_name = '1_min'+'_'+todayT1 = strptime('%s 09:31:00' % today, '%Y%m%d %H:%M:%S')T2 = strptime('%s 11:31:00' % today, '%Y%m%d %H:%M:%S')T3 = strptime('%s 13:01:00' % today, '%Y%m%d %H:%M:%S')T4 = strptime('%s 15:01:00' % today, '%Y%m%d %H:%M:%S')# start_run(1)if t < T1:    sleep((T1.tm_hour - t.tm_hour) * 3600 + (T1.tm_min - t.tm_min) * 60 + T1.tm_sec - t.tm_sec)    start_run(240)elif T1 <= t < T2:    delay_loop = calculate_sleep_loop(t)    total_loop_counter = 240 - delay_loop[1]    sleep(delay_loop[0])    start_run(delay_loop[1])elif T2 <= t < T3:    sleep((T3.tm_hour - t.tm_hour) * 3600 + (T3.tm_min - t.tm_min) * 60 + T3.tm_sec - t.tm_sec)    total_loop_counter = 121    start_run(120)elif T3 <= t < T4:    delay_loop = calculate_sleep_loop(t)    total_loop_counter = 240 - delay_loop[1]    sleep(delay_loop[0])    start_run(delay_loop[1])else:    print "the trading is over!"