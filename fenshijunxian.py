# coding:UTF-8from pandas import DataFramefrom time import sleep, localtime, clock, time, strptimefrom datetime import datetimefrom csv import readerfrom sqlalchemy import create_engineimport socketPAGE_NUMBERS = 100REDUNDANT_NUMBERS_CHARS_IN_LINE = 4INTERVAL_SECONDS = 60URL = 'http://hq.sinajs.cn/list='PATH_ALL_CODE = r'C:\Users\zzw\Desktop\allcode.csv'try:    from urllib.request import urlopen, Requestexcept ImportError:    from urllib2 import urlopen, Requestdef calculate_sleep_loop(para_time):    today = str(para_time.tm_year)+str(para_time.tm_mon)+str(para_time.tm_mday)    t1 = strptime('%s 09:31:00' % today, '%Y%m%d %H:%M:%S')    t2 = strptime('%s 11:31:00' % today, '%Y%m%d %H:%M:%S')    t3 = strptime('%s 13:01:00' % today, '%Y%m%d %H:%M:%S')    t4 = strptime('%s 15:01:00' % today, '%Y%m%d %H:%M:%S')    if para_time < t1:        delay_sec = get_seconds(t1, para_time)        loop_times = 240    elif t1 <= para_time < t2 or t3 <= para_time < t4:        if para_time.tm_sec <= 2:            delay_sec = 0            t_hour = para_time.tm_hour            t_min = para_time.tm_min        else:            delay_sec = 60-para_time.tm_sec            if para_time.tm_min == 59:                t_min = 0                t_hour = para_time.tm_hour+1            else:                t_hour = para_time.tm_hour                t_min = para_time.tm_min+1        if para_time.tm_hour < 12:            loop_times = 240-(t_hour*60+t_min-9*60-31)        else:            loop_times = 15*60-t_hour*60-t_min+1    elif t2 <= para_time < t3:        delay_sec = get_seconds(t3, para_time)        loop_times = 120    else:        return []    return [delay_sec, loop_times]def get_seconds(time1, time2):    return (time1.tm_hour - time2.tm_hour) * 3600 + (time1.tm_min - time2.tm_min) * 60 + time1.tm_sec - time2.tm_secdef parse_data_string(para_string):    return_list = []    if len(para_string) < 40:        return return_list    str1 = para_string[para_string.find('"')+1:len(para_string)-REDUNDANT_NUMBERS_CHARS_IN_LINE]    str_list = str1.split(',')    # stock_name = str_list[0]    open_price = float(str_list[1])    settlement = float(str_list[2])    latest_price = float(str_list[3])    high_price = float(str_list[4])    low_price = float(str_list[5])    buy1_price = float(str_list[6])    sell1_price = float(str_list[7])    volume = int(str_list[8])    amount = long(str_list[9][0:str_list[9].find('.')])    trading_date = str_list[30]    trading_time = str_list[31]    quote_datetime = datetime.strptime(trading_date + ' ' + trading_time, "%Y-%m-%d %H:%M:%S")    return_list = [open_price, settlement, latest_price, high_price, low_price, buy1_price,                   sell1_price, volume, amount, quote_datetime]    return return_listdef get_data_from_web(code_str):    global total_loop_counter    # code_str is a long string containing many stock codes split by comma    code_list = code_str.split(',')    url = URL+'%s' % code_str    try:        request = Request(url)        lines = urlopen(request, timeout=20).read()        data_list = lines.split(';')        del data_list[len(data_list)-1]        result_list = []        for i in range(0, len(data_list)):            single_stock_list = parse_data_string(data_list[i])            if len(single_stock_list) == 0:                continue            else:                if single_stock_list[8] != 0:                    single_stock_list.insert(0, code_list[i])                    result_list.append(single_stock_list)        return result_list    except socket.timeout:        print 'a timeout error happens , continue catch data '        data_to_sql()def get_quotedata_list():    with open(PATH_ALL_CODE, 'r') as csv_file:        spam_reader = reader(csv_file, delimiter=' ', quotechar='|')        controller = 0        counter = 0        final_list = []        code_str = ''        for row in spam_reader:            controller += 1            counter += 1            if controller % PAGE_NUMBERS == 1:                code_str = row[0]            else:                code_str = code_str+','+row[0]            if controller == PAGE_NUMBERS:                final_list.extend(get_data_from_web(code_str))                controller = 0                code_str = ''        if controller != 0 and controller < PAGE_NUMBERS:            final_list.extend(get_data_from_web(code_str))    csv_file.close()    return final_listdef data_to_sql():    global time_recorder    start = clock()    li = get_quotedata_list()    stock_list = []    for i in range(0, len(li)):        stock_list.append(li[i][0])        del li[i][0]    df1 = DataFrame(li, columns=['open', 'settlement', 'close', 'high', 'low', 'buy1_price',                                 'sell1_price', 'volume', 'amount', 'datetime'], index=stock_list)    df1.index.name = 'stockcode'    temp_df = df1.pop('datetime')    df1.insert(0, 'datetime', temp_df)    df1.insert(8, 'av_p', df1['amount']/df1['volume'])    indicator = DataFrame(df1['close'] / df1['av_p'], index=df1.index, columns=list(['indicator']))    indicator[indicator >= 0.994] = 1    indicator[indicator <= 0.994] = 0    df1['indicator'] = indicator    series_index = DataFrame([total_loop_counter]*len(li), index=df1.index, columns=list(['series_index']))    df1.insert(1, 'series_index', series_index)    engine = create_engine('mysql://root:@localhost/stockdata?charset=utf8')    engine.execute('create table if not exists %s like table_template' % table_name)    df1.to_sql(table_name, engine, if_exists='append')    end = clock()    time_recorder = end-startdef start_run(loop_num):    global total_loop_counter    for i in range(0, loop_num):        total_loop_counter += 1        data_to_sql()        sleep_time = INTERVAL_SECONDS - time_recorder        if total_loop_counter == 120:            t = localtime(time())            today = str(t.tm_year)+str(t.tm_mon)+str(t.tm_mday)            t3 = strptime('%s 13:01:00' % today, '%Y%m%d %H:%M:%S')            print 'will sleep %d minutes and %f seconds' % ((get_seconds(t3, t) - sleep_time) / 60,                                                            (get_seconds(t3, t) - sleep_time) % 60)            sleep(get_seconds(t3, t) - sleep_time)        print 'the next loop is %d ' % total_loop_counter        sleep(sleep_time)def main():    global total_loop_counter    global table_name    t = localtime(time())    today = str(t.tm_year)+str(t.tm_mon)+str(t.tm_mday)    table_name = '1_min'+'_'+today    delay_loop = calculate_sleep_loop(t)    if len(delay_loop) > 0:        sleep(delay_loop[0])        total_loop_counter = 240 - delay_loop[1]        start_run(delay_loop[1])    else:        print "the trading is over!"time_recorder = 0total_loop_counter = 0table_name = ''main()